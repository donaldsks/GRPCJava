apply plugin: "cpp"
apply plugin: "com.google.protobuf"

description = 'The protoc plugin for gRPC Java'

buildscript {
    repositories {
        mavenCentral()
        mavenLocal()
    }
    dependencies {
        classpath libraries.protobuf_plugin
    }
}

// When there is only one platform available, Gradle doesn't create a directory
// for the sole platform. In order to keep the script simple, we intentionally
// always build the 'local_arch' even though it's duplicate with one of the
// targetArchs, so that we always have at least two platforms.
def targetArchs = ['local_arch'] as HashSet

def artifactStagingPath = "$buildDir/artifacts" as File
def artifactPath = { arch ->
  return "$artifactStagingPath/java_pluginExecutable/" + arch + "/${protocPluginBaseName}.exe"
}


if (System.env.TARGET_ARCHS != null) {
  def archs = System.env.TARGET_ARCHS.split(' +')
  targetArchs.addAll(archs)
} else {
  targetArchs.add(osdetector.arch)
}

// Adds space-delimited arguments from the environment variable env to the
// argList.
def addEnvArgs = { env, argList ->
  def value = System.getenv(env)
  if (value != null) {
    value.split(' +').each() { it -> argList.add(it) }
  }
}

// Adds corresponding "-l" option to the argList if libName is not found in
// LDFLAGS. This is only used for Mac because when building for uploadArchives
// artifacts, we add the ".a" files directly to LDFLAGS and without "-l" in
// order to get statically linked, otherwise we add the libraries through "-l"
// so that they can be searched for in default search paths.
def addLibraryIfNotLinked = { libName, argList ->
  def ldflags = System.env.LDFLAGS
  if (ldflags == null || !ldflags.contains('lib' + libName + '.a')) {
    argList.add('-l' + libName)
  }
}

model {
  toolChains {
    gcc(Gcc) {
      target("x86_64") {
        cppCompiler.withArguments { args ->
          args << "-m64"
        }
        linker.withArguments { args ->
          args << "-m64"
        }
      }
      target("x86_32") {
        cppCompiler.withArguments { args ->
          args << "-m32"
        }
        linker.withArguments { args ->
          args << "-m32"
        }
      }
      target('local_arch') { }
    }
    clang(Clang) {
      target("x86_64") {
        cppCompiler.withArguments { args ->
          args << "-m64"
        }
        linker.withArguments { args ->
          args << "-m64"
        }
      }
      target('local_arch') { }
    }
  }
  platforms {
    x86_32 {
      architecture "x86_32"
    }
    x86_64 {
      architecture "x86_64"
    }
    local_arch {
      architecture 'local_arch'
    }
  }

  components {
    java_plugin(NativeExecutableSpec) {
      targetArchs.each {
        targetPlatform it
      }
      baseName "$protocPluginBaseName"
    }
  }
}

dependencies {
  testCompile project(':grpc-protobuf'),
              project(':grpc-stub')
}

binaries.all {
  if (toolChain in Gcc || toolChain in Clang) {
    cppCompiler.args "--std=c++0x"
    addEnvArgs("CXXFLAGS", cppCompiler.args)
    addEnvArgs("CPPFLAGS", cppCompiler.args)
    if (osdetector.os == "osx") {
      cppCompiler.args "-mmacosx-version-min=10.7", "-stdlib=libc++"
      addLibraryIfNotLinked('protoc', linker.args)
      addLibraryIfNotLinked('protobuf', linker.args)
    } else if (osdetector.os == "windows") {
      linker.args "-static", "-lprotoc", "-lprotobuf", "-static-libgcc", "-static-libstdc++", "-s"
    } else {
      // Link protoc, protobuf, libgcc and libstdc++ statically.
      // Link other (system) libraries dynamically.
      // Clang under OSX doesn't support these options.
      linker.args "-Wl,-Bstatic", "-lprotoc", "-lprotobuf", "-static-libgcc", "-static-libstdc++",
                  "-Wl,-Bdynamic", "-lpthread", "-s"
    }
    addEnvArgs("LDFLAGS", linker.args)
  } else if (toolChain in VisualCpp) {
    cppCompiler.args "/EHsc", "/MD"
    if (rootProject.hasProperty('protobuf.include')) {
      cppCompiler.args "/I" + rootProject.properties['protobuf.include']
    }
    linker.args "libprotobuf.lib", "libprotoc.lib"
    if (rootProject.hasProperty('protobuf.libs')) {
      linker.args "/LIBPATH:" + rootProject.properties['protobuf.libs']
    }
  }
}

task buildArtifacts(type: Copy) {
  targetArchs.each {
    dependsOn it + 'Java_pluginExecutable'
  }
  from("$buildDir/binaries") {
    if (osdetector.os != 'windows') {
      rename 'protoc-gen-grpc-java', '$0.exe'
    }
  }
  into artifactStagingPath
}

archivesBaseName = "$protocPluginBaseName"

artifacts {
  for (arch in (targetArchs - 'local_arch')) {
    archives(artifactPath(arch) as File) {
      classifier osdetector.os + "-" + arch
      type "exe"
      extension "exe"
      builtBy buildArtifacts
    }
  }
}

// Exe files are skipped by Maven by default. Override it.
// Also skip jar files that is generated by the java plugin.
[
  install.repositories.mavenInstaller,
  uploadArchives.repositories.mavenDeployer,
]*.addFilter('all') {artifact, file ->
  ! (file.getName().endsWith('jar') || file.getName().endsWith('jar.asc'))
}

[
  uploadArchives.repositories.mavenDeployer,
]*.beforeDeployment {
  for (arch in (targetArchs - 'local_arch')) {
    def ret = exec {
      executable 'bash'
      args 'check-artifact.sh', osdetector.os, arch
    }
    if (ret.exitValue != 0) {
      throw new GradleException("check-artifact.sh exited with " + ret.exitValue)
    }
  }
}

protobufCodeGenPlugins = ["java_plugin:$javaPluginPath"]

project.afterEvaluate {
  generateTestProto.dependsOn 'local_archJava_pluginExecutable'
}

// Ignore test for the moment on Windows. It will be easier to run once the
// gradle protobuf plugin can support nano.
if (osdetector.os != 'windows') {
  test.dependsOn('testGolden','testNanoGolden')
}

task testGolden(type: Exec, dependsOn: 'generateTestProto') {
  if (osdetector.os != 'windows') {
    executable "diff"
  } else {
    executable "fc"
  }
  // File isn't found on Windows if last slash is forward-slash
  def slash = System.getProperty("file.separator")
  args "$buildDir/generated-sources/test/io/grpc/testing/integration" + slash + "TestServiceGrpc.java",
       "$projectDir/src/test/golden/TestService.java.txt"
}

task testNanoGolden(type: Exec, dependsOn: 'local_archJava_pluginExecutable') {
  doFirst {
      temporaryDir.createNewFile();
  }

  environment 'TEST_TMP_DIR', temporaryDir
  commandLine './src/test/run_nano_test.sh'
}
